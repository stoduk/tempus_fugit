#!/usr/bin/env python

import os
import sys
import time
from daemon import Daemon
import syslog
import traceback
import picamera
import datetime

### XXX temp - until mopiapi in right directory
sys.path.append("/usr/sbin/")
### XXX temp
import mopiapi

class TempusFugit(Daemon):
    """Raspberry Pi time lapse daemon

    Designed to be run at startup on a Raspberry Pi running a MoPi power
    monitor - such that we will be started once the RPi is up and running,
    we'll do our work, and then ask MoPi to turn RPi off and wake up again
    later.  Much like a hardware cron job.

    This is designed with a network-unattahed RPi model A running off batteries
    - this will give the longest possible battery life for our time lapse, but
    to get sane dates on the photos we'll want a hardware RTC connected too.

    The device is likely to be run remotely to the person who knows how to fix
    it, so the aim is that everything can be run without needing an attached
    monitor or any great intelligence.  The device will snap pictures away
    at the configured times, and when a USB drive is plugged in it will update
    itself and copy off any photos taken.  Nice and simple.

    The work to do on each power up is:
    - if a USB drive is found, copy over any new configuration
     (this is useful as we are running remotely and not network connected)
    - take a photo!
    - if a USB drive is found, copy off any photos and log files (eg. to
     indicate power state)
    """
    UPDATE_DIR = "update/"
    OUTPUT_DIR = "/home/pi/tempus_fugit"
    ISO_TIME_FMT = "%Y%m%dT%H%M%S"

    def __init__(self, *args, **kwargs):
        self.do_update = False
        self.have_usb = False
        try:
            os.mkdir(self.OUTPUT_DIR)
        except OSError:
            if not os.path.exists(self.OUTPUT_DIR):
                raise
        super(TempusFugit, self).__init__(*args, **kwargs)

    @staticmethod
    def log(str):
        syslog.syslog(str)
    @staticmethod
    def logerr(str):
        syslog.syslog(syslog.LOGERR, str)

    def _find_usbdrive(self, mountpoint="/media/usb0/"):
        """Look for an attached USB drive.  We are using "usbmount" to handle
        usb drive insertion, so it should be as simple as seeing if there is
        anything under /media/usb0 (as we should only ever have a single device
        connected on a single USB port Model A!
        """
        if os.path.ismount(mountpoint):
            self.have_usb = True
            if os.path.exists(os.path.join(mountpoint, self.UPDATE_DIR)):
                self.do_update = True
    def _take_picture(self):
        """Do the work of taking a picture

        TBD:
        - what resolution?  MAX_RESOLUTION creates 2.2Mb files, 1024x768 creates 485Kb (for jpeg)
        - do I want to stick in any EXIF data?  My name, GPS info (which I'd fake), etc.
        """
        fname = "%s.jpg" % (datetime.datetime.today().strftime(self.ISO_TIME_FMT))
        fname = os.path.join(self.OUTPUT_DIR, fname)
        with picamera.PiCamera() as camera:
            camera.resolution = (1024, 768) # TBD - do I want 
            camera.capture(fname)

    def run(self):
        try:
            self.log("starting")
            self._find_usbdrive()
            self.log("Have drive %s, do update %s" % (self.have_usb, self.do_update))

            # XXX do we have any script/config update?  If so, move those over and reboot 
            # immediately (don't want to get stuck in a loop always updating, hence move 
            # rather than copy - could do the same with diff or md5 comparison)

            # XXX decide if we should take a photo - probably don't want manual
            # turn on (for updates/copying images off) to skew when we run
            self._take_picture()

            # XXX copy images over.  ideally we'd have some way to know what we've already
            # copied (just create some .foo file on USB drive containing files we've seen?)
            # and a way to trigger deletion of files from local store (create some file with magic name?)

            # XXX copy log file over.  Some way to scrub the log could be useful in case it gets too big

            # XXX figure out when next to startup - most the time this will just be the
            # frequency we want to run at (ie. if ever hour, just sleep for an hour)
            # but need to be cleverer to cope with manual poewr on

            # XXX set next power on, and power off immediately.

            self.log("shutting down")
        except Exception as e:
            self.error("something went wrong")
            self.error(traceback.format_exc())

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print "ERROR: invalid args.  %s {pidfile}" % (sys.argv[0])
        sys.exit(1)
    pidfile = sys.argv[1]
    daemon = TempusFugit(pidfile)
    daemon.start()
