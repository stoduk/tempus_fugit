#!/usr/bin/env python

import os
import sys
import time
from daemon import Daemon
import syslog
import traceback
import picamera
import datetime
import sunrise
import subprocess
import decimal
import shutil
import errno
import pickle
from collections import namedtuple

### XXX temp - until mopiapi in right directory
sys.path.append("/usr/sbin/")
### XXX temp
import mopiapi

def roundTime(dt=None, roundTo=60*30):
   """Round a datetime object to any time laps in seconds
   dt : datetime.datetime object, default now.
   roundTo : Closest number of seconds to round to, default 30 minutes.
   Author: Thierry Husson 2012 - Use it as you want but don't blame me.

   From: http://stackoverflow.com/questions/3463930/how-to-round-the-minute-of-a-datetime-object-python/10854034#10854034
   """
   if dt == None : dt = datetime.datetime.now()
   seconds = (dt - dt.min).seconds
   # // is a floor division, not a comment on following line:
   rounding = (seconds+roundTo/2) // roundTo * roundTo
   return dt + datetime.timedelta(0,rounding-seconds,-dt.microsecond)

class TempusFugit(Daemon):
    """Raspberry Pi time lapse daemon

    Designed to be run at startup on a Raspberry Pi running a MoPi power
    monitor - such that we will be started once the RPi is up and running,
    we'll do our work, and then ask MoPi to turn RPi off and wake up again
    later.  Much like a hardware cron job.

    This is designed with a network-unattahed RPi model A running off batteries
    - this will give the longest possible battery life for our time lapse, but
    to get sane dates on the photos we'll want a hardware RTC connected too.

    The device is likely to be run remotely to the person who knows how to fix
    it, so the aim is that everything can be run without needing an attached
    monitor or any great intelligence.  The device will snap pictures away
    at the configured times, and when a USB drive is plugged in it will update
    itself and copy off any photos taken.  Nice and simple.

    The work to do on each power up is:
    - if a USB drive is found, copy over any new configuration
     (this is useful as we are running remotely and not network connected)
    - take a photo!
    - if a USB drive is found, copy off any photos and log files (eg. to
     indicate power state)
    """
    MY_NAME = "tempus_fugit"
    UPDATE_DIR = "update/"
    OUTPUT_DIR = "/home/pi/%s/photos/" % (MY_NAME)
    USBDRIVE_MOUNTPOINT = "/media/usb0/"
    USBDRIVE_CONTROL_DIR = os.path.join(USBDRIVE_MOUNTPOINT, "%s/" % MY_NAME)
    USBDRIVE_PHOTO_DIR = os.path.join(USBDRIVE_MOUNTPOINT, "photos/")
    ISO_TIME_FMT = "%Y%m%dT%H%M%S"
    MAGIC_FILE_BLOCK_RELOAD = "block_reload"
    MAGIC_FILE_SAVED_FILES = "saved_files"
    MAGIC_FILE_DELETE_FILES = "saved_files.done"

    def __init__(self, *args, **kwargs):
        self.do_update = False
        self.have_usb = False
        self.block_reload = False
        try:
            os.mkdir(self.OUTPUT_DIR)
        except OSError:
            if not os.path.exists(self.OUTPUT_DIR):
                raise

        self.longitude = kwargs.pop("longitude", -0.3524)
        self.latitude = kwargs.pop("latitude", 51.8175)

        super(TempusFugit, self).__init__(*args, **kwargs)

    @staticmethod
    def log(*args):
        if len(args) == 1:
            if isinstance(args[0], str):
                msg = str(args[0])
        else:
            msg = str(args)
        syslog.syslog(msg)
    @staticmethod
    def logerr(msg):
        syslog.syslog(syslog.LOG_ERR, msg)

    @staticmethod
    def _pause_for_ntp():
        """Block waiting for ntpd to have a valid peer - we assume that as
        soon as we have a valid peer the system time will be correct, as RPi
        using '-g' option
        """
        def uptime():
            with open('/proc/uptime', 'r') as f:
                return decimal.Decimal(f.readline().split()[0])

        start_time = uptime()
        while True:
            for line in subprocess.check_output(["ntpdc", "-c sysinfo"], stderr=subprocess.STDOUT).split("\n"):
                if line.startswith("system peer:"):
                    peer = line.replace("system peer:", "")
                    peer = peer.strip()
                    print peer
                    if peer == "0.0.0.0":
                        print "Peer unknown"
                    else:
                        print "Peer found - stop"
                        return uptime() - start_time
            print "."
            time.sleep(0.1)

    def _find_usbdrive(self, mountpoint=USBDRIVE_MOUNTPOINT):
        """Look for an attached USB drive.  We are using "usbmount" to handle
        usb drive insertion, so it should be as simple as seeing if there is
        anything under /media/usb0 (as we should only ever have a single device
        connected on a single USB port Model A!
        """
        if os.path.ismount(mountpoint):
            self.have_usb = True
            if os.path.exists(os.path.join(mountpoint, self.UPDATE_DIR)):
                self.do_update = True
            if os.path.exists(os.path.join(mountpoint, self.USBDRIVE_CONTROL_DIR, self.MAGIC_FILE_BLOCK_RELOAD)):
                self.block_reload = True
    def _take_photo(self):
        """Do the work of taking a photo

        EXIF data is modified to add:
        - copyright notice (currently my name and current year; config should
          allow user to be specified)
        - GPS location (which is obviously hardcoded as we have no GPS!
          Currently hard coded to Harpenden location, it should be possible
          to get this from self.latitude and self.logitude but the format
          needs converting)

        TBD:
        - what resolution?  MAX_RESOLUTION creates 2.2Mb files, 1024x768 creates 485Kb (for jpeg)
        """
        fname = "%s.jpg" % (datetime.datetime.today().strftime(self.ISO_TIME_FMT))
        fname = os.path.join(self.OUTPUT_DIR, fname)
        with picamera.PiCamera() as camera:
            camera.resolution = (1024, 768) # TBD - do I want 
            camera.exif_tags["IFD0.Copyright"] = 'Copyright (c) %s Anthony Toole' % (datetime.datetime.now().year)
            camera.exif_tags["GPS.GPSLatitudeRef"] = "N"
            camera.exif_tags["GPS.GPSLatitude"] = "51/1,49/1,0/1"
            camera.exif_tags["GPS.GPSLongitudeRef"] = "W"
            camera.exif_tags["GPS.GPSLongitude"] = "0/1,21/1,25/1"

            camera.capture(fname)

    def _get_photo_archive_info(self, copy=True):
        """Return information on the locally stored photos, using the 
        information stored on the USB drive to indicate the last file copied.

        'copy' argument shows which file to look for - True for copy
        operations, False for delete operations (remember that the user
        manually renames the magic file to indicate that files previously
        copied to USB drive have been verified and safely backed up

        Returns a namedtuple containing:
        - last_filename_copied: the name of the last file copied from local
          store to USB drive
        - archived: a list of files (in increasing date order) up to and
          including last_filename_copied.  For delete operations this indicates
          all the files that have been copied to USB and that the user has
          indicated are safe to delete.  For copy operations this indicates the
          files that have already been copied to USB drive (but not necessarily
          saved elsewhere yet)
        - unarchived: a list of files (in increasing date order) that are newer
          than last_filename_copied.  For delete operations this indicates
          files that have not been archived yet (and so must not be deleted
          locally!).  For copy operations this indicates files that have not
          been copied to USB drive yet.
        """
        magic_fname = self.MAGIC_FILE_SAVED_FILES if copy else self.MAGIC_FILE_DELETE_FILES
        fname = os.path.join(self.USBDRIVE_CONTROL_DIR, magic_fname)

        if os.path.exists(fname):
            with open(fname) as f:
                last_filename_copied = pickle.load(f)
            if not copy:
                # As we are about to delete all the files already copied, delete
                # the control file - the deletes can't realistically fail (and if it could then we'll just recopy those files)
                os.remove(fname)

        else:
            last_filename_copied = None # all files will be considered unarchived compared to this

        # File name is YYYYMMDDTHHMMSS.jpg - so sorting will give us files
        # in increasing date order
        files = os.listdir(self.OUTPUT_DIR)
        files.sort()

        if last_filename_copied and not last_filename_copied in files:
            self.logerr("Last saved file '%s' is not found in local store - assume all files are unarchived, as something is very wrong" % (last_filename_copied))
            last_filename_copied = None

        return namedtuple("photoarchive", "last_filename_copied archived unarchived")(
            last_filename_copied,
            [x for x in files if x <= last_filename_copied],
            [x for x in files if x > last_filename_copied])

    def _remove_old_files(self):
        """Remove the files that have been archived elsewhere

        The interface for this is pretty simple - when we copy files we do
        this in age order (stopping if we run out of space), and store the
        details of the last file copied over.  If the user wants the files to be deleted then they simply rename the file to indicate that.

        This copes with several situations:
        - USB drive left plugged in indefinitely.  Until the magic file appears
          we will not remove any files from our local store, and will only copy
          over until we've run out of space (at which point we'll still store
          photos locally, but not on the USB drive)
        - The user inserts a fresh USB drive (after having used a different
          drive previously, but without deleting the locally stored copies
          of those files).  We fail safe in this case and assume the previously
          copied files are gone - and so recopy everything again.  It is up to
          the user to deal with any duplication here - which should be easy due
          to timestamps in filenames.
        - USB drive plugged in for the first time.  This will behave exactly
          like the previous case!
        - The user deletes an old magic file.  This is the same as the fresh
          USB drive case ie. we assume that nothing local has been copied
          and let the user sort out any duplication.
        """
        info = self._get_photo_archive_info(copy=False)
        if info.last_filename_copied:
            os.chdir(self.OUTPUT_DIR)
            archived = info.archived if info.archived else ["none", "none"]
            unarchived = info.unarchived if info.unarchived else ["none", "none"]
            self.log(
                "Deleting %s files up to and including %s; leaving %s files "
                "[delete: %s-%s; keep: %s-%s]" % 
                (len(info.archived), info.last_filename_copied,
                 len(info.unarchived), archived[0], archived[-1],
                 unarchived[0], unarchived[-1]))
            for file in info.archived:
                os.remove(file)

            # The record of files to delete has already been removed by worker above
            # No need to create a new last_filename_copied control file - as
            # we'll just copy everything if it isn't there, as we want.
        else:
            self.log("No delete file found, no files to delete")

    def _write_readme_file(self):
        instructions = """Instructions for tempus_fugit program

The time lapse module will sit there and turn itself on once every 1/2 hour
between sunrise and sunset, snapping a picture each time.

If a USB drive is found then photos will be copied off, with a meta-data file
being created to show the last file copied.

When files have been verified and saved elsewhere (eg. Flickr) then the
meta-data file on the USB drive should be renamed (from
'%s' to '%s', both in %s directory),
which will trigger all the archived files to be deleted from the time lapse
setup.

If the time lapse is turned on manually then it will do an archive immediately
but will not take a photo.
""" % (self.MAGIC_FILE_SAVED_FILES, self.MAGIC_FILE_DELETE_FILES, self.MY_NAME)
        if self.have_usb:
            fname = os.path.join(self.USBDRIVE_MOUNTPOINT, "README.txt")
            if os.path.exists(fname) and not "tempus_fugit" in open(fname).readline():
                self.logerr("Readme file exists but doesn't appear to be ours - do nothing")
            else:
                with open(fname, "w") as f:
                    f.write(instructions)
                
    def _copy_files(self):
        """At some level this is simple - copy all photos and logs to the
        attached USB drive.

        The complexity appears because we want to have a way to specify that
        (on a later USB insert) that "seen" files should be deleted - we
        require manual intervention here to make sure that these files have
        been backed up somewhere before we delete them

        We force the manual step to avoid the case where a USB drive remains
        plugged in but somehow gets corrupted - we don't want to remove
        the local copy of files until we are sure the files on the USB drive
        have been seen and verified.

        So basically we create a file in the target directory containing
        (a pickled) list of files that have been copied - when the user has
        checked these copied correctly they can rename that file to have all
        photos referenced in it deleted.  Obviously the names of the original
        and renamed pickle files are well known.
        """
        def free_space_mb():
            stat = os.statvfs(self.USBDRIVE_MOUNTPOINT)
            return stat.f_bsize * stat.f_bavail / 1024. / 1024.
        info = self._get_photo_archive_info(copy=True)
        fs_before = free_space_mb()

        try:
            # Swallow out of space error for this, syslog large so likely!
            shutil.copy("/var/log/syslog", self.USBDRIVE_MOUNTPOINT)
        except IOError as e:
            if e.errno != errno.ENOSPC:
                raise

        os.chdir(self.OUTPUT_DIR)
        if not os.path.exists(self.USBDRIVE_PHOTO_DIR):
            os.mkdir(self.USBDRIVE_PHOTO_DIR) 

        last_copied = info.last_filename_copied
        for file in info.unarchived:
            try:
                shutil.copy(file, self.USBDRIVE_PHOTO_DIR)
                last_copied = file
            except IOError as e:
                # Out of space error is expected so swallow just that.  Sadly
                # I get a different error on the USB drive I was using
                #  (errno.EINTR) so swallow all IOError and tidy up as best we
                # can - if the drive is totally hosed then the cleanup (or 
                # pickle file write) will bail out in a similar way so we'll
                # see that
                # 
                # Helpfully shutil.copy will leave a partially copied file,
                # so lets tidy up
                fname = os.path.join(self.USBDRIVE_PHOTO_DIR, file)
                os.remove(fname)

        copied = [x for x in info.unarchived if x <= last_copied] or ["none", "none"]
        uncopied = [x for x in info.unarchived if x > last_copied] or ["none", "none"]

        fs_after = free_space_mb()
        self.log(
            "Copying files: %s available to copy after file %s; %s copied; %s "
            "uncompied [copied %s-%s, uncopied %s-%s]; "
            "free space before %sMb, after %sMb" % 
            (len(info.unarchived), info.last_filename_copied, len(copied),
             len(uncopied), copied[0], copied[-1], uncopied[0], uncopied[-1],
             fs_before, fs_after))

        # Store the name of the last file we saved, so we can resume next time
        pickle.dump(last_copied, open(os.path.join(self.USBDRIVE_CONTROL_DIR, self.MAGIC_FILE_SAVED_FILES), "w"))

    def _think_hard(self):
        """Work out what needs to be done, including:

        - whether we need to update our scripts or config
          We do this if there is "new" scripts/config present, which we
          decide based on an MD5 hash of the old and new files
        - whether we need to take a photo
          We take a photo if we've been woken up by the timer (or if this is
          our first power on), but not if we've been woken up by a button
          press (which is used to trigger updates and offloading of photos)
        - whether we need to copy off photos and logs, and delete local copies
          We copy files off if there is a USB drive present - ordinarily we
          just copy files over, leaving a backup locally.  If there is a magic
          file on the USB drive however we will trigger removal of old photos
          (which obviously requires remembering which photos have been
          copied already!), and the same for log files.
        - when we need to schedule our next wake up
          Eventually I'll probably allow some way to specify exactly when
          to take photos (perhaps in some cron style syntax) - but for now
          just take a photo every 1/2 hour between sunrise and sunset.
        """

        # XXX ART TODO: do we need to update our scripts?
        self.update_config = False

        # XXX usb
        self._find_usbdrive()
        self.log("Have drive %s, do update %s, block reload %s" % (self.have_usb, self.do_update, self.block_reload))


        # Note: though we could just look at the current time to decide whether
        # this is a photo taking time that might not be very accurate as RPi's
        # view of time (via hardware RTC) and MoPi's view of time (via a simple
        # counter in microcontroller, I believe) are likely to differ.  So we'd
        # need to cope with being woken up a little early or a little late and
        # still do the right thing, and given we can also be woken up manually
        # that is likely to be complicated.
        #
        # So we just use the MoPi's power on delay value, which means we'll
        # at worst just take an extra photo when power is first turned on to
        # MoPi:
        #
        # If MoPi's power on delay is non-zero then we haven't been woken up by 
        # MoPi and so this is a manual startup (ie. a button press, to trigger 
        # copying from/to USB).  If the power on delay is zero then it could be 
        # that the timer expired or could be that the MoPi is being powered for 
        # the first time - treat both the same and take a picture now.
        self.mopi = mopiapi.mopiapi()
        pod =  self.mopi.getPowerOnDelay()
        voltage = self.mopi.getVoltage()

        if pod == 0:
            self.take_photo = True
        else:
            self.take_photo = False

        self.remove_old_files = self.have_usb
        self.copy_files = self.have_usb

        self.log("Actions: update config %s, take photo %s, copy files %s, remove old files %s" % (self.update_config, self.take_photo, self.copy_files, self.remove_old_files))

        # For now we just take photos every 1/2 hour between sunrise and
        # sunset.  In future it might be nice to take extra photos around
        # sunrise/sunset but our startup time might not be very accurate
        # so it could be easier in that case to just stay powered on for the
        # first/last 15 minutes of light or so.
        s = sunrise.sun(lat=self.latitude, long=self.longitude, return_dates=True)
        now = datetime.datetime.now()
        srise = s.sunrise()
        sset = s.sunset()
        if now < srise or now > sset:
            # It doesn't matter why we are awake (manual intervention or some
            # timing error) - either way we'll wake when it is next light
            # (ie. sunrise either today or tomorrow)
            self.log("Woken at night! (now %s, sunrise %s, sunset %s, power on delay %s)" % (now, srise, sset, pod))
            if now < srise:
                target = srise
            else:
                target = s.sunrise(tomorrow=True)
            # Round *up* to the next 1/2 hour
            wakeup = roundTime(target)
            if wakeup < target:
                wakeup += datetime.timedelta(seconds=60*30)
        elif pod == 0:
            # We've been woken by timer (or first power up, which we cheat and
            # treat the same) - schedule next photo in half hour.
            # First round the current time to nearest 1/2 hour (in either direction)
            # as clock skew could make it seem that we've woken up "too early" or "too late"
            wakeup = roundTime(now) + datetime.timedelta(seconds=60*30)
        else:
            # we've been woken up manually, so our next wake up will be in less
            # than half hour - round *up* to next half hour
            target = now
            wakeup = roundTime(target)
            if wakeup < target:
                wakeup += datetime.timedelta(seconds=60*30)
        self.wakeup = wakeup
        self.log("Target wakeup time %s based on current time %s, power on delay %s [supply voltage %s]" % (self.wakeup, now, pod, voltage))

    def _schedule_wake_up(self):
        seconds = (self.wakeup - datetime.datetime.now()).seconds
        self.log("Setting wakeup in %s seconds, shut down immediately active %s" % (seconds, not self.block_reload))
        self.mopi.setPowerOnDelay(seconds)
        if not self.block_reload:
            self.mopi.setShutdownDelay(1)
        
    def run(self):
        try:
            # log time for now, as I'm dubious about system time for now
            # (I think when we've had power off we'll be run with the last
            # known time which isn't good - hopefully RTC can be setup to
            # sort local time before anything starts running to avoid this)

            # My doubt about system time is increasing!  RPi runs ntpd with -g option
            # so it should set system time as soon as it gets an ntp peer - so make
            # sure we don't proceed until we've got a valid peer
            first_time = datetime.datetime.now()
            ntp_duration = self._pause_for_ntp()
            second_time = datetime.datetime.now()
            time_diff = second_time - first_time - datetime.timedelta(seconds=float(ntp_duration))
            if time_diff < datetime.timedelta():
                time_diff = "-%s" % (abs(time_diff))
            self.log("*** starting at %s; after %s seconds: %s; difference of %s" % (first_time, ntp_duration, second_time, time_diff))

            self._think_hard()

            # XXX do we have any script/config update?  If so, move those over and reboot 
            # immediately (don't want to get stuck in a loop always updating, hence move 
            # rather than copy - could do the same with diff or md5 comparison)
            if self.update_config:
                self.log("ERROR: haven't implemented script/config update!!")

            # Remove old files - obviously do this before writing new files
            # in case we need to the space we are going to free up!
            if self.remove_old_files:
                self._remove_old_files()

            # Write our instructional README file to the USB drive
            self._write_readme_file()

            # XXX decide if we should take a photo - probably don't want manual
            # turn on (for updates/copying images off) to skew when we run
            if self.take_photo:
                self._take_photo()

            # XXX copy images over.  ideally we'd have some way to know what we've already
            # copied (just create some .foo file on USB drive containing files we've seen?)
            # and a way to trigger deletion of files from local store (create some file with magic name?)
            # XXX copy log file over.  Some way to scrub the log could be useful in case it gets too big
            if self.copy_files:
                self._copy_files()

            # schedule next power on, and power off immediately
            self._schedule_wake_up()

            self.log("shutting down at %s" % (datetime.datetime.now()))
        except Exception as e:
            self.logerr("something went wrong")
            self.logerr(traceback.format_exc())

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print "ERROR: invalid args.  %s {pidfile}" % (sys.argv[0])
        sys.exit(1)
    pidfile = sys.argv[1]
    daemon = TempusFugit(pidfile)
    daemon.start()
